# Plan: compareto_overflow

## Rule idea
Detect `compareTo` method implementations that use integer subtraction (`isub`) to compute the return value, which can produce incorrect comparison ordering for extreme integer values due to arithmetic overflow.

## Problem description
A common Java anti-pattern is writing `compareTo` like:

```java
public int compareTo(MyObj other) {
    return this.value - other.value;  // Bug: overflows for extreme values
}
```

When `this.value = Integer.MAX_VALUE` and `other.value = -1`, the subtraction overflows and produces a negative result, reversing the intended ordering. The correct fix is to use `Integer.compare(this.value, other.value)`.

This bug is hard to notice during code review because the code looks reasonable at first glance, especially for developers unfamiliar with integer overflow semantics.

## Detection strategy

Bytecode-level detection:

1. Filter methods named `compareTo` whose descriptor returns `int` (ends with `)I`).
2. Scan the method's basic block instructions for the `isub` opcode (0x64).
3. Exclude methods that also call `java/lang/Integer.compare` or `java/lang/Long.compare`, which are the safe alternatives.
4. Report the method at the offset of the first `isub` instruction found.

This approach detects the common patterns:
- `return this.value - other.value;` (direct: isub → ireturn)
- `int diff = this.value - other.value; return diff;` (indirect: isub → istore → iload → ireturn)

The exclusion of `Integer.compare` / `Long.compare` calls reduces false positives for `compareTo` methods that use subtraction for non-comparison intermediate calculations but use safe comparison utilities for the actual return value.

## Scope

**In scope:**
- Any method named `compareTo` with int return type (`*I` descriptor) in analysis target classes.
- Detection of `isub` instruction in basic block instructions.
- Exclusion of methods calling `java/lang/Integer.compare` or `java/lang/Long.compare`.

**Non-goals:**
- Detecting `lsub`-based overflow (long arithmetic narrowed to int).
- Cross-method detection (comparator lambda bodies in other methods).
- Detecting other forms of overflow in non-`compareTo` methods.
- Annotation-based suppression: `@Suppress`-style annotations are not supported.
- Non-JSpecify annotation semantics are not supported.

## Determinism constraints
- Iterate over basic blocks and instructions in the order provided by `method.cfg.blocks`.
- Sort findings by (class name, method name, descriptor, offset) before emitting.
- This guarantees stable output across repeated runs.

## Test strategy
- TP: Class implementing `Comparable<T>` with `return this.field - other.field` in compareTo.
- TN: Class using `Integer.compare(this.field, other.field)` in compareTo.
- TN: Class using `Comparator.comparingInt(...)` (no `compareTo` with isub).
- Edge: Class with a bridge `compareTo(Object)` method generated by compiler — should not double-report.
- Edge: Class with `compareTo` that uses subtraction for an intermediate non-comparison purpose but calls `Integer.compare` for the actual return — should not report (excluded by Integer.compare call).

## Complexity
- O(N × M) where N = number of methods per class and M = number of instructions per method.
- No inter-method or inter-class analysis required; each method is evaluated independently.

## Risks
- [ ] False positive: `isub` used for intermediate non-comparison calculation without Integer.compare. Mitigation: exclusion of `Integer.compare`/`Long.compare` calls reduces common cases; spec documents this as an accepted low-frequency FP.
- [ ] Bridge method double-reporting: compiler-generated bridge `compareTo(Object)` that delegates to `compareTo(MyClass)` may also contain `isub` if the delegation introduces one (unlikely since bridge methods typically just cast and delegate). Mitigation: check actual instruction content.
- [ ] `isub` opcode not in `src/opcodes.rs`: must add `ISUB = 0x64` before using it.
